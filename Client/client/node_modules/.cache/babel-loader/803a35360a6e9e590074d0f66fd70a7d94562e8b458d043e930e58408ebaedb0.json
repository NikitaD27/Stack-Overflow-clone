{"ast":null,"code":"\"use strict\";\n\nconst _Error = require(\"./Error\");\nconst utils = require(\"./utils\");\nconst {\n  StripeAPIError,\n  StripeAuthenticationError,\n  StripeConnectionError,\n  StripeError,\n  StripePermissionError,\n  StripeRateLimitError\n} = _Error;\nconst {\n  HttpClient\n} = require('./net/HttpClient');\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n  constructor(stripe, maxBufferedRequestMetric) {\n    this._stripe = stripe;\n    this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n  }\n  _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  }\n  _makeResponseEvent(requestEvent, statusCode, headers) {\n    const requestEndTime = Date.now();\n    const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return utils.removeNullish({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime\n    });\n  }\n  _getRequestId(headers) {\n    return headers['request-id'];\n  }\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler(requestEvent, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const streamCompleteCallback = () => {\n        const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n        this._stripe._emitter.emit('response', responseEvent);\n        this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed);\n      };\n      const stream = res.toStream(streamCompleteCallback);\n      // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n      this._addHeadersDirectlyToObject(stream, headers);\n      return callback(null, stream);\n    };\n  }\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler(requestEvent, callback) {\n    return res => {\n      const headers = res.getHeaders();\n      const requestId = this._getRequestId(headers);\n      const statusCode = res.getStatusCode();\n      const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n      this._stripe._emitter.emit('response', responseEvent);\n      res.toJSON().then(jsonResponse => {\n        if (jsonResponse.error) {\n          let err;\n          // Convert OAuth error responses into a standard format\n          // so that the rest of the error logic can be shared\n          if (typeof jsonResponse.error === 'string') {\n            jsonResponse.error = {\n              type: jsonResponse.error,\n              message: jsonResponse.error_description\n            };\n          }\n          jsonResponse.error.headers = headers;\n          jsonResponse.error.statusCode = statusCode;\n          jsonResponse.error.requestId = requestId;\n          if (statusCode === 401) {\n            err = new StripeAuthenticationError(jsonResponse.error);\n          } else if (statusCode === 403) {\n            err = new StripePermissionError(jsonResponse.error);\n          } else if (statusCode === 429) {\n            err = new StripeRateLimitError(jsonResponse.error);\n          } else {\n            err = StripeError.generate(jsonResponse.error);\n          }\n          throw err;\n        }\n        return jsonResponse;\n      }, e => {\n        throw new StripeAPIError({\n          message: 'Invalid JSON received from the Stripe API',\n          exception: e,\n          requestId: headers['request-id']\n        });\n      }).then(jsonResponse => {\n        this._recordRequestMetrics(requestId, responseEvent.elapsed);\n        // Expose raw response object.\n        const rawResponse = res.getRawResponse();\n        this._addHeadersDirectlyToObject(rawResponse, headers);\n        Object.defineProperty(jsonResponse, 'lastResponse', {\n          enumerable: false,\n          writable: false,\n          value: rawResponse\n        });\n        callback(null, jsonResponse);\n      }, e => callback(e, null));\n    };\n  }\n  static _generateConnectionErrorMessage(requestRetries) {\n    return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n  }\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  static _shouldRetry(res, numRetries, maxRetries, error) {\n    if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n      return true;\n    }\n    // Do not retry if we are out of retries.\n    if (numRetries >= maxRetries) {\n      return false;\n    }\n    // Retry on connection error.\n    if (!res) {\n      return true;\n    }\n    // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    }\n    // Retry on conflict errors.\n    if (res.getStatusCode() === 409) {\n      return true;\n    }\n    // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n    return false;\n  }\n  _getSleepTimeInMS(numRetries) {\n    let retryAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n    const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n    // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n    let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n    // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n    sleepSeconds *= 0.5 * (1 + Math.random());\n    // But never sleep less than the base sleep seconds.\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n    // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n    return sleepSeconds * 1000;\n  }\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries() {\n    let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return settings.maxNetworkRetries && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n  }\n  _defaultIdempotencyKey(method, settings) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    const maxRetries = this._getMaxNetworkRetries(settings);\n    if (method === 'POST' && maxRetries > 0) {\n      return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n    }\n    return null;\n  }\n  _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n    const defaultHeaders = {\n      // Use specified auth token or use default from this stripe instance:\n      Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'User-Agent': this._getUserAgentString(),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n      'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)\n    };\n    // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n    const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n    // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        utils.emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n      }\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n    return Object.assign(utils.removeNullish(defaultHeaders),\n    // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n    utils.normalizeHeaders(userSuppliedHeaders));\n  }\n  _getUserAgentString() {\n    const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n    const appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n    return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n  }\n  _getTelemetryHeader() {\n    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n      const metrics = this._stripe._prevRequestMetrics.shift();\n      return JSON.stringify({\n        last_request_metrics: metrics\n      });\n    }\n  }\n  _recordRequestMetrics(requestId, requestDurationMs) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n        utils.emitWarning('Request metrics buffer is full, dropping telemetry message.');\n      } else {\n        this._stripe._prevRequestMetrics.push({\n          request_id: requestId,\n          request_duration_ms: requestDurationMs\n        });\n      }\n    }\n  }\n  _request(method, host, path, data, auth) {\n    let options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    let callback = arguments.length > 6 ? arguments[6] : undefined;\n    let requestDataProcessor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n    let requestData;\n    const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n      return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n    };\n    const makeRequest = (apiVersion, headers, numRetries) => {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      const timeout = options.settings && options.settings.timeout && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : this._stripe.getApiField('timeout');\n      const req = this._stripe.getApiField('httpClient').makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n      const requestStartTime = Date.now();\n      // @ts-ignore\n      const requestEvent = utils.removeNullish({\n        api_version: apiVersion,\n        account: headers['Stripe-Account'],\n        idempotency_key: headers['Idempotency-Key'],\n        method,\n        path,\n        request_start_time: requestStartTime\n      });\n      const requestRetries = numRetries || 0;\n      const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n      this._stripe._emitter.emit('request', requestEvent);\n      req.then(res => {\n        if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries,\n          // @ts-ignore\n          res.getHeaders()['retry-after']);\n        } else if (options.streaming && res.getStatusCode() < 400) {\n          return this._streamingResponseHandler(requestEvent, callback)(res);\n        } else {\n          return this._jsonResponseHandler(requestEvent, callback)(res);\n        }\n      }).catch(error => {\n        if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n        } else {\n          const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n          return callback(new StripeConnectionError({\n            message: isTimeoutError ? `Request aborted due to timeout being reached (${timeout}ms)` : RequestSender._generateConnectionErrorMessage(requestRetries),\n            // @ts-ignore\n            detail: error\n          }));\n        }\n      });\n    };\n    const prepareAndMakeRequest = (error, data) => {\n      if (error) {\n        return callback(error);\n      }\n      requestData = data;\n      this._stripe.getClientUserAgent(clientUserAgent => {\n        var _a, _b;\n        const apiVersion = this._stripe.getApiField('version');\n        const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n        makeRequest(apiVersion, headers, 0);\n      });\n    };\n    if (requestDataProcessor) {\n      requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n    } else {\n      prepareAndMakeRequest(null, utils.stringifyRequestData(data || {}));\n    }\n  }\n}\nmodule.exports = RequestSender;","map":{"version":3,"names":["_Error","require","utils","StripeAPIError","StripeAuthenticationError","StripeConnectionError","StripeError","StripePermissionError","StripeRateLimitError","HttpClient","MAX_RETRY_AFTER_WAIT","RequestSender","constructor","stripe","maxBufferedRequestMetric","_stripe","_maxBufferedRequestMetric","_addHeadersDirectlyToObject","obj","headers","requestId","stripeAccount","apiVersion","idempotencyKey","_makeResponseEvent","requestEvent","statusCode","requestEndTime","Date","now","requestDurationMs","request_start_time","removeNullish","api_version","account","idempotency_key","method","path","status","request_id","_getRequestId","elapsed","request_end_time","_streamingResponseHandler","callback","res","getHeaders","streamCompleteCallback","responseEvent","getStatusCode","_emitter","emit","_recordRequestMetrics","stream","toStream","_jsonResponseHandler","toJSON","then","jsonResponse","error","err","type","message","error_description","generate","e","exception","rawResponse","getRawResponse","Object","defineProperty","enumerable","writable","value","_generateConnectionErrorMessage","requestRetries","_shouldRetry","numRetries","maxRetries","CONNECTION_CLOSED_ERROR_CODES","includes","code","_getSleepTimeInMS","retryAfter","initialNetworkRetryDelay","getInitialNetworkRetryDelay","maxNetworkRetryDelay","getMaxNetworkRetryDelay","sleepSeconds","Math","min","pow","random","max","Number","isInteger","_getMaxNetworkRetries","settings","maxNetworkRetries","getMaxNetworkRetries","_defaultIdempotencyKey","_platformFunctions","uuid4","_makeHeaders","auth","contentLength","clientUserAgent","userSuppliedHeaders","userSuppliedSettings","defaultHeaders","Authorization","getApiField","Accept","_getUserAgentString","_getTelemetryHeader","methodHasPayload","emitWarning","assign","normalizeHeaders","packageVersion","getConstant","appInfo","_appInfo","getAppInfoAsString","trim","getTelemetryEnabled","_prevRequestMetrics","length","metrics","shift","JSON","stringify","last_request_metrics","push","request_duration_ms","_request","host","data","options","requestDataProcessor","requestData","retryRequest","requestFn","setTimeout","makeRequest","timeout","req","requestStartTime","streaming","catch","isTimeoutError","TIMEOUT_ERROR_CODE","detail","prepareAndMakeRequest","getClientUserAgent","_a","_b","stringifyRequestData","module","exports"],"sources":["C:/Users/Nikita/Stack Overflow Clone/Client/client/node_modules/stripe/lib/RequestSender.js"],"sourcesContent":["\"use strict\";\nconst _Error = require(\"./Error\");\nconst utils = require(\"./utils\");\nconst { StripeAPIError, StripeAuthenticationError, StripeConnectionError, StripeError, StripePermissionError, StripeRateLimitError, } = _Error;\nconst { HttpClient } = require('./net/HttpClient');\nconst MAX_RETRY_AFTER_WAIT = 60;\nclass RequestSender {\n    constructor(stripe, maxBufferedRequestMetric) {\n        this._stripe = stripe;\n        this._maxBufferedRequestMetric = maxBufferedRequestMetric;\n    }\n    _addHeadersDirectlyToObject(obj, headers) {\n        // For convenience, make some headers easily accessible on\n        // lastResponse.\n        // NOTE: Stripe responds with lowercase header names/keys.\n        obj.requestId = headers['request-id'];\n        obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n        obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n        obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n    }\n    _makeResponseEvent(requestEvent, statusCode, headers) {\n        const requestEndTime = Date.now();\n        const requestDurationMs = requestEndTime - requestEvent.request_start_time;\n        return utils.removeNullish({\n            api_version: headers['stripe-version'],\n            account: headers['stripe-account'],\n            idempotency_key: headers['idempotency-key'],\n            method: requestEvent.method,\n            path: requestEvent.path,\n            status: statusCode,\n            request_id: this._getRequestId(headers),\n            elapsed: requestDurationMs,\n            request_start_time: requestEvent.request_start_time,\n            request_end_time: requestEndTime,\n        });\n    }\n    _getRequestId(headers) {\n        return headers['request-id'];\n    }\n    /**\n     * Used by methods with spec.streaming === true. For these methods, we do not\n     * buffer successful responses into memory or do parse them into stripe\n     * objects, we delegate that all of that to the user and pass back the raw\n     * http.Response object to the callback.\n     *\n     * (Unsuccessful responses shouldn't make it here, they should\n     * still be buffered/parsed and handled by _jsonResponseHandler -- see\n     * makeRequest)\n     */\n    _streamingResponseHandler(requestEvent, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const streamCompleteCallback = () => {\n                const responseEvent = this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n                this._stripe._emitter.emit('response', responseEvent);\n                this._recordRequestMetrics(this._getRequestId(headers), responseEvent.elapsed);\n            };\n            const stream = res.toStream(streamCompleteCallback);\n            // This is here for backwards compatibility, as the stream is a raw\n            // HTTP response in Node and the legacy behavior was to mutate this\n            // response.\n            this._addHeadersDirectlyToObject(stream, headers);\n            return callback(null, stream);\n        };\n    }\n    /**\n     * Default handler for Stripe responses. Buffers the response into memory,\n     * parses the JSON and returns it (i.e. passes it to the callback) if there\n     * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n     */\n    _jsonResponseHandler(requestEvent, callback) {\n        return (res) => {\n            const headers = res.getHeaders();\n            const requestId = this._getRequestId(headers);\n            const statusCode = res.getStatusCode();\n            const responseEvent = this._makeResponseEvent(requestEvent, statusCode, headers);\n            this._stripe._emitter.emit('response', responseEvent);\n            res\n                .toJSON()\n                .then((jsonResponse) => {\n                if (jsonResponse.error) {\n                    let err;\n                    // Convert OAuth error responses into a standard format\n                    // so that the rest of the error logic can be shared\n                    if (typeof jsonResponse.error === 'string') {\n                        jsonResponse.error = {\n                            type: jsonResponse.error,\n                            message: jsonResponse.error_description,\n                        };\n                    }\n                    jsonResponse.error.headers = headers;\n                    jsonResponse.error.statusCode = statusCode;\n                    jsonResponse.error.requestId = requestId;\n                    if (statusCode === 401) {\n                        err = new StripeAuthenticationError(jsonResponse.error);\n                    }\n                    else if (statusCode === 403) {\n                        err = new StripePermissionError(jsonResponse.error);\n                    }\n                    else if (statusCode === 429) {\n                        err = new StripeRateLimitError(jsonResponse.error);\n                    }\n                    else {\n                        err = StripeError.generate(jsonResponse.error);\n                    }\n                    throw err;\n                }\n                return jsonResponse;\n            }, (e) => {\n                throw new StripeAPIError({\n                    message: 'Invalid JSON received from the Stripe API',\n                    exception: e,\n                    requestId: headers['request-id'],\n                });\n            })\n                .then((jsonResponse) => {\n                this._recordRequestMetrics(requestId, responseEvent.elapsed);\n                // Expose raw response object.\n                const rawResponse = res.getRawResponse();\n                this._addHeadersDirectlyToObject(rawResponse, headers);\n                Object.defineProperty(jsonResponse, 'lastResponse', {\n                    enumerable: false,\n                    writable: false,\n                    value: rawResponse,\n                });\n                callback(null, jsonResponse);\n            }, (e) => callback(e, null));\n        };\n    }\n    static _generateConnectionErrorMessage(requestRetries) {\n        return `An error occurred with our connection to Stripe.${requestRetries > 0 ? ` Request was retried ${requestRetries} times.` : ''}`;\n    }\n    // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n    static _shouldRetry(res, numRetries, maxRetries, error) {\n        if (error &&\n            numRetries === 0 &&\n            HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n            return true;\n        }\n        // Do not retry if we are out of retries.\n        if (numRetries >= maxRetries) {\n            return false;\n        }\n        // Retry on connection error.\n        if (!res) {\n            return true;\n        }\n        // The API may ask us not to retry (e.g., if doing so would be a no-op)\n        // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n        if (res.getHeaders()['stripe-should-retry'] === 'false') {\n            return false;\n        }\n        if (res.getHeaders()['stripe-should-retry'] === 'true') {\n            return true;\n        }\n        // Retry on conflict errors.\n        if (res.getStatusCode() === 409) {\n            return true;\n        }\n        // Retry on 500, 503, and other internal errors.\n        //\n        // Note that we expect the stripe-should-retry header to be false\n        // in most cases when a 500 is returned, since our idempotency framework\n        // would typically replay it anyway.\n        if (res.getStatusCode() >= 500) {\n            return true;\n        }\n        return false;\n    }\n    _getSleepTimeInMS(numRetries, retryAfter = null) {\n        const initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n        const maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay();\n        // Apply exponential backoff with initialNetworkRetryDelay on the\n        // number of numRetries so far as inputs. Do not allow the number to exceed\n        // maxNetworkRetryDelay.\n        let sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay);\n        // Apply some jitter by randomizing the value in the range of\n        // (sleepSeconds / 2) to (sleepSeconds).\n        sleepSeconds *= 0.5 * (1 + Math.random());\n        // But never sleep less than the base sleep seconds.\n        sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds);\n        // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n        if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n            sleepSeconds = Math.max(sleepSeconds, retryAfter);\n        }\n        return sleepSeconds * 1000;\n    }\n    // Max retries can be set on a per request basis. Favor those over the global setting\n    _getMaxNetworkRetries(settings = {}) {\n        return settings.maxNetworkRetries &&\n            Number.isInteger(settings.maxNetworkRetries)\n            ? settings.maxNetworkRetries\n            : this._stripe.getMaxNetworkRetries();\n    }\n    _defaultIdempotencyKey(method, settings) {\n        // If this is a POST and we allow multiple retries, ensure an idempotency key.\n        const maxRetries = this._getMaxNetworkRetries(settings);\n        if (method === 'POST' && maxRetries > 0) {\n            return `stripe-node-retry-${this._stripe._platformFunctions.uuid4()}`;\n        }\n        return null;\n    }\n    _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n        const defaultHeaders = {\n            // Use specified auth token or use default from this stripe instance:\n            Authorization: auth ? `Bearer ${auth}` : this._stripe.getApiField('auth'),\n            Accept: 'application/json',\n            'Content-Type': 'application/x-www-form-urlencoded',\n            'User-Agent': this._getUserAgentString(),\n            'X-Stripe-Client-User-Agent': clientUserAgent,\n            'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n            'Stripe-Version': apiVersion,\n            'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n            'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings),\n        };\n        // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n        //   A user agent SHOULD send a Content-Length in a request message when\n        //   no Transfer-Encoding is sent and the request method defines a meaning\n        //   for an enclosed payload body.  For example, a Content-Length header\n        //   field is normally sent in a POST request even when the value is 0\n        //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n        //   Content-Length header field when the request message does not contain\n        //   a payload body and the method semantics do not anticipate such a\n        //   body.\n        //\n        // These method types are expected to have bodies and so we should always\n        // include a Content-Length.\n        const methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH';\n        // If a content length was specified, we always include it regardless of\n        // whether the method semantics anticipate such a body. This keeps us\n        // consistent with historical behavior. We do however want to warn on this\n        // and fix these cases as they are semantically incorrect.\n        if (methodHasPayload || contentLength) {\n            if (!methodHasPayload) {\n                utils.emitWarning(`${method} method had non-zero contentLength but no payload is expected for this verb`);\n            }\n            defaultHeaders['Content-Length'] = contentLength;\n        }\n        return Object.assign(utils.removeNullish(defaultHeaders), \n        // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n        utils.normalizeHeaders(userSuppliedHeaders));\n    }\n    _getUserAgentString() {\n        const packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n        const appInfo = this._stripe._appInfo\n            ? this._stripe.getAppInfoAsString()\n            : '';\n        return `Stripe/v1 NodeBindings/${packageVersion} ${appInfo}`.trim();\n    }\n    _getTelemetryHeader() {\n        if (this._stripe.getTelemetryEnabled() &&\n            this._stripe._prevRequestMetrics.length > 0) {\n            const metrics = this._stripe._prevRequestMetrics.shift();\n            return JSON.stringify({\n                last_request_metrics: metrics,\n            });\n        }\n    }\n    _recordRequestMetrics(requestId, requestDurationMs) {\n        if (this._stripe.getTelemetryEnabled() && requestId) {\n            if (this._stripe._prevRequestMetrics.length > this._maxBufferedRequestMetric) {\n                utils.emitWarning('Request metrics buffer is full, dropping telemetry message.');\n            }\n            else {\n                this._stripe._prevRequestMetrics.push({\n                    request_id: requestId,\n                    request_duration_ms: requestDurationMs,\n                });\n            }\n        }\n    }\n    _request(method, host, path, data, auth, options = {}, callback, requestDataProcessor = null) {\n        let requestData;\n        const retryRequest = (requestFn, apiVersion, headers, requestRetries, retryAfter) => {\n            return setTimeout(requestFn, this._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n        };\n        const makeRequest = (apiVersion, headers, numRetries) => {\n            // timeout can be set on a per-request basis. Favor that over the global setting\n            const timeout = options.settings &&\n                options.settings.timeout &&\n                Number.isInteger(options.settings.timeout) &&\n                options.settings.timeout >= 0\n                ? options.settings.timeout\n                : this._stripe.getApiField('timeout');\n            const req = this._stripe\n                .getApiField('httpClient')\n                .makeRequest(host || this._stripe.getApiField('host'), this._stripe.getApiField('port'), path, method, headers, requestData, this._stripe.getApiField('protocol'), timeout);\n            const requestStartTime = Date.now();\n            // @ts-ignore\n            const requestEvent = utils.removeNullish({\n                api_version: apiVersion,\n                account: headers['Stripe-Account'],\n                idempotency_key: headers['Idempotency-Key'],\n                method,\n                path,\n                request_start_time: requestStartTime,\n            });\n            const requestRetries = numRetries || 0;\n            const maxRetries = this._getMaxNetworkRetries(options.settings || {});\n            this._stripe._emitter.emit('request', requestEvent);\n            req\n                .then((res) => {\n                if (RequestSender._shouldRetry(res, requestRetries, maxRetries)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, \n                    // @ts-ignore\n                    res.getHeaders()['retry-after']);\n                }\n                else if (options.streaming && res.getStatusCode() < 400) {\n                    return this._streamingResponseHandler(requestEvent, callback)(res);\n                }\n                else {\n                    return this._jsonResponseHandler(requestEvent, callback)(res);\n                }\n            })\n                .catch((error) => {\n                if (RequestSender._shouldRetry(null, requestRetries, maxRetries, error)) {\n                    return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n                }\n                else {\n                    const isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n                    return callback(new StripeConnectionError({\n                        message: isTimeoutError\n                            ? `Request aborted due to timeout being reached (${timeout}ms)`\n                            : RequestSender._generateConnectionErrorMessage(requestRetries),\n                        // @ts-ignore\n                        detail: error,\n                    }));\n                }\n            });\n        };\n        const prepareAndMakeRequest = (error, data) => {\n            if (error) {\n                return callback(error);\n            }\n            requestData = data;\n            this._stripe.getClientUserAgent((clientUserAgent) => {\n                var _a, _b;\n                const apiVersion = this._stripe.getApiField('version');\n                const headers = this._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, (_a = options.headers) !== null && _a !== void 0 ? _a : null, (_b = options.settings) !== null && _b !== void 0 ? _b : {});\n                makeRequest(apiVersion, headers, 0);\n            });\n        };\n        if (requestDataProcessor) {\n            requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n        }\n        else {\n            prepareAndMakeRequest(null, utils.stringifyRequestData(data || {}));\n        }\n    }\n}\nmodule.exports = RequestSender;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}