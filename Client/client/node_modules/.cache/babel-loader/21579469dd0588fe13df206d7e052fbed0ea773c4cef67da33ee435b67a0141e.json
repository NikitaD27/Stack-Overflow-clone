{"ast":null,"code":"\"use strict\";\n\nconst _Error = require(\"./Error\");\nconst {\n  StripeError,\n  StripeSignatureVerificationError\n} = _Error;\nconst Webhook = {\n  DEFAULT_TOLERANCE: 300,\n  // @ts-ignore\n  signature: null,\n  constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n    this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n    const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);\n    return jsonPayload;\n  },\n  async constructEventAsync(payload, header, secret, tolerance, cryptoProvider) {\n    await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n    const jsonPayload = payload instanceof Uint8Array ? JSON.parse(new TextDecoder('utf8').decode(payload)) : JSON.parse(payload);\n    return jsonPayload;\n  },\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n   */\n  generateTestHeaderString: function (opts) {\n    if (!opts) {\n      throw new StripeError({\n        message: 'Options are required'\n      });\n    }\n    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    opts.cryptoProvider = opts.cryptoProvider || getCryptoProvider();\n    opts.signature = opts.signature || opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n    const generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');\n    return generatedHeader;\n  },\n  _createCryptoProvider: () => null,\n  _platformFunctions: null\n};\nconst signature = {\n  EXPECTED_SCHEME: 'v1',\n  verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getCryptoProvider();\n    const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n    validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n    return true;\n  },\n  async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n    const {\n      decodedHeader: header,\n      decodedPayload: payload,\n      details\n    } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n    cryptoProvider = cryptoProvider || getCryptoProvider();\n    const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n    return validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n  }\n};\nfunction makeHMACContent(payload, details) {\n  return `${details.timestamp}.${payload}`;\n}\nfunction parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n  const textDecoder = new TextDecoder('utf8');\n  const decodedPayload = encodedPayload instanceof Uint8Array ? textDecoder.decode(encodedPayload) : encodedPayload;\n  // Express's type for `Request#headers` is `string | []string`\n  // which is because the `set-cookie` header is an array,\n  // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n  // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n  if (Array.isArray(encodedHeader)) {\n    throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n  }\n  const decodedHeader = encodedHeader instanceof Uint8Array ? textDecoder.decode(encodedHeader) : encodedHeader;\n  const details = parseHeader(decodedHeader, expectedScheme);\n  if (!details || details.timestamp === -1) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: 'Unable to extract timestamp and signatures from header'\n    });\n  }\n  if (!details.signatures.length) {\n    throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n      message: 'No signatures found with expected scheme'\n    });\n  }\n  return {\n    decodedPayload,\n    decodedHeader,\n    details\n  };\n}\nfunction validateComputedSignature(payload, header, details, expectedSignature, tolerance) {\n  const signatureFound = !!details.signatures.filter(Webhook._platformFunctions.secureCompare.bind(Webhook._platformFunctions, expectedSignature)).length;\n  if (!signatureFound) {\n    // @ts-ignore\n    throw new StripeSignatureVerificationError(header, payload, {\n      message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe?' + ' https://github.com/stripe/stripe-node#webhook-signing'\n    });\n  }\n  const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n  if (tolerance > 0 && timestampAge > tolerance) {\n    // @ts-ignore\n    throw new StripeSignatureVerificationError(header, payload, {\n      message: 'Timestamp outside the tolerance zone'\n    });\n  }\n  return true;\n}\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n  return header.split(',').reduce((accum, item) => {\n    const kv = item.split('=');\n    if (kv[0] === 't') {\n      accum.timestamp = parseInt(kv[1], 10);\n    }\n    if (kv[0] === scheme) {\n      accum.signatures.push(kv[1]);\n    }\n    return accum;\n  }, {\n    timestamp: -1,\n    signatures: []\n  });\n}\nlet webhooksCryptoProviderInstance = null;\n/**\n * Lazily instantiate a CryptoProvider instance. This is a stateless object\n * so a singleton can be used here.\n */\nfunction getCryptoProvider() {\n  if (!webhooksCryptoProviderInstance) {\n    webhooksCryptoProviderInstance = Webhook._createCryptoProvider();\n  }\n  return webhooksCryptoProviderInstance;\n}\nWebhook.signature = signature;\nmodule.exports = Webhook;","map":{"version":3,"names":["_Error","require","StripeError","StripeSignatureVerificationError","Webhook","DEFAULT_TOLERANCE","signature","constructEvent","payload","header","secret","tolerance","cryptoProvider","verifyHeader","jsonPayload","Uint8Array","JSON","parse","TextDecoder","decode","constructEventAsync","verifyHeaderAsync","generateTestHeaderString","opts","message","timestamp","Math","floor","Date","now","scheme","EXPECTED_SCHEME","getCryptoProvider","computeHMACSignature","generatedHeader","join","_createCryptoProvider","_platformFunctions","encodedPayload","encodedHeader","decodedHeader","decodedPayload","details","parseEventDetails","expectedSignature","makeHMACContent","validateComputedSignature","computeHMACSignatureAsync","expectedScheme","textDecoder","Array","isArray","Error","parseHeader","signatures","length","signatureFound","filter","secureCompare","bind","timestampAge","split","reduce","accum","item","kv","parseInt","push","webhooksCryptoProviderInstance","module","exports"],"sources":["C:/Users/Nikita/Stack Overflow Clone/Client/client/node_modules/stripe/lib/Webhooks.js"],"sourcesContent":["\"use strict\";\nconst _Error = require(\"./Error\");\nconst { StripeError, StripeSignatureVerificationError } = _Error;\nconst Webhook = {\n    DEFAULT_TOLERANCE: 300,\n    // @ts-ignore\n    signature: null,\n    constructEvent(payload, header, secret, tolerance, cryptoProvider) {\n        this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n        const jsonPayload = payload instanceof Uint8Array\n            ? JSON.parse(new TextDecoder('utf8').decode(payload))\n            : JSON.parse(payload);\n        return jsonPayload;\n    },\n    async constructEventAsync(payload, header, secret, tolerance, cryptoProvider) {\n        await this.signature.verifyHeaderAsync(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE, cryptoProvider);\n        const jsonPayload = payload instanceof Uint8Array\n            ? JSON.parse(new TextDecoder('utf8').decode(payload))\n            : JSON.parse(payload);\n        return jsonPayload;\n    },\n    /**\n     * Generates a header to be used for webhook mocking\n     *\n     * @typedef {object} opts\n     * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n     * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n     * @property {string} secret - Stripe webhook secret 'whsec_...'\n     * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n     * @property {string} signature - Computed webhook signature\n     * @property {CryptoProvider} cryptoProvider - Crypto provider to use for computing the signature if none was provided. Defaults to NodeCryptoProvider.\n     */\n    generateTestHeaderString: function (opts) {\n        if (!opts) {\n            throw new StripeError({\n                message: 'Options are required',\n            });\n        }\n        opts.timestamp =\n            Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n        opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n        opts.cryptoProvider = opts.cryptoProvider || getCryptoProvider();\n        opts.signature =\n            opts.signature ||\n                opts.cryptoProvider.computeHMACSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n        const generatedHeader = [\n            't=' + opts.timestamp,\n            opts.scheme + '=' + opts.signature,\n        ].join(',');\n        return generatedHeader;\n    },\n    _createCryptoProvider: () => null,\n    _platformFunctions: null,\n};\nconst signature = {\n    EXPECTED_SCHEME: 'v1',\n    verifyHeader(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n        const { decodedHeader: header, decodedPayload: payload, details, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n        cryptoProvider = cryptoProvider || getCryptoProvider();\n        const expectedSignature = cryptoProvider.computeHMACSignature(makeHMACContent(payload, details), secret);\n        validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n        return true;\n    },\n    async verifyHeaderAsync(encodedPayload, encodedHeader, secret, tolerance, cryptoProvider) {\n        const { decodedHeader: header, decodedPayload: payload, details, } = parseEventDetails(encodedPayload, encodedHeader, this.EXPECTED_SCHEME);\n        cryptoProvider = cryptoProvider || getCryptoProvider();\n        const expectedSignature = await cryptoProvider.computeHMACSignatureAsync(makeHMACContent(payload, details), secret);\n        return validateComputedSignature(payload, header, details, expectedSignature, tolerance);\n    },\n};\nfunction makeHMACContent(payload, details) {\n    return `${details.timestamp}.${payload}`;\n}\nfunction parseEventDetails(encodedPayload, encodedHeader, expectedScheme) {\n    const textDecoder = new TextDecoder('utf8');\n    const decodedPayload = encodedPayload instanceof Uint8Array\n        ? textDecoder.decode(encodedPayload)\n        : encodedPayload;\n    // Express's type for `Request#headers` is `string | []string`\n    // which is because the `set-cookie` header is an array,\n    // but no other headers are an array (docs: https://nodejs.org/api/http.html#http_message_headers)\n    // (Express's Request class is an extension of http.IncomingMessage, and doesn't appear to be relevantly modified: https://github.com/expressjs/express/blob/master/lib/request.js#L31)\n    if (Array.isArray(encodedHeader)) {\n        throw new Error('Unexpected: An array was passed as a header, which should not be possible for the stripe-signature header.');\n    }\n    const decodedHeader = encodedHeader instanceof Uint8Array\n        ? textDecoder.decode(encodedHeader)\n        : encodedHeader;\n    const details = parseHeader(decodedHeader, expectedScheme);\n    if (!details || details.timestamp === -1) {\n        throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n            message: 'Unable to extract timestamp and signatures from header',\n        });\n    }\n    if (!details.signatures.length) {\n        throw new StripeSignatureVerificationError(decodedHeader, decodedPayload, {\n            message: 'No signatures found with expected scheme',\n        });\n    }\n    return {\n        decodedPayload,\n        decodedHeader,\n        details,\n    };\n}\nfunction validateComputedSignature(payload, header, details, expectedSignature, tolerance) {\n    const signatureFound = !!details.signatures.filter(Webhook._platformFunctions.secureCompare.bind(Webhook._platformFunctions, expectedSignature)).length;\n    if (!signatureFound) {\n        // @ts-ignore\n        throw new StripeSignatureVerificationError(header, payload, {\n            message: 'No signatures found matching the expected signature for payload.' +\n                ' Are you passing the raw request body you received from Stripe?' +\n                ' https://github.com/stripe/stripe-node#webhook-signing',\n        });\n    }\n    const timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n    if (tolerance > 0 && timestampAge > tolerance) {\n        // @ts-ignore\n        throw new StripeSignatureVerificationError(header, payload, {\n            message: 'Timestamp outside the tolerance zone',\n        });\n    }\n    return true;\n}\nfunction parseHeader(header, scheme) {\n    if (typeof header !== 'string') {\n        return null;\n    }\n    return header.split(',').reduce((accum, item) => {\n        const kv = item.split('=');\n        if (kv[0] === 't') {\n            accum.timestamp = parseInt(kv[1], 10);\n        }\n        if (kv[0] === scheme) {\n            accum.signatures.push(kv[1]);\n        }\n        return accum;\n    }, {\n        timestamp: -1,\n        signatures: [],\n    });\n}\nlet webhooksCryptoProviderInstance = null;\n/**\n * Lazily instantiate a CryptoProvider instance. This is a stateless object\n * so a singleton can be used here.\n */\nfunction getCryptoProvider() {\n    if (!webhooksCryptoProviderInstance) {\n        webhooksCryptoProviderInstance = Webhook._createCryptoProvider();\n    }\n    return webhooksCryptoProviderInstance;\n}\nWebhook.signature = signature;\nmodule.exports = Webhook;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}